# AMD ROCm 架构图示

## 1. 整体架构层次图

```
┌───────────────────────────────────────────────────────────────┐
│                         应用层                                 │
│  CUDA/HIP应用    OpenCL应用    PyTorch    TensorFlow          │
└───────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌───────────────────────────────────────────────────────────────┐
│                     HIP Runtime (CLR)                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐     │
│  │ hipMalloc│  │hipMemcpy │  │hipLaunch │  │hipStream │     │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘     │
│              clr/hipamd - HIP API实现                          │
└───────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌───────────────────────────────────────────────────────────────┐
│                  ROCclr (Runtime Common Layer)                │
│  ┌─────────────────────────────────────────────────────┐     │
│  │  Device Abstraction (设备抽象层)                     │     │
│  │  • Memory Management (内存管理)                      │     │
│  │  • Command Queue (命令队列)                          │     │
│  │  • Kernel Execution (内核执行)                       │     │
│  │  • Context Management (上下文管理)                   │     │
│  └─────────────────────────────────────────────────────┘     │
│              clr/rocclr - 统一运行时抽象                       │
└───────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌───────────────────────────────────────────────────────────────┐
│                    HSA Runtime (ROCr)                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │ Agent Mgmt   │  │ Queue Mgmt   │  │ Memory Mgmt  │       │
│  │ (设备管理)    │  │ (队列管理)   │  │ (内存管理)    │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │ Signal Sync  │  │ AQL Dispatch │  │ Topology     │       │
│  │ (信号同步)    │  │ (AQL调度)    │  │ (拓扑发现)    │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
│          rocr-runtime/runtime - HSA标准实现                    │
└───────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌───────────────────────────────────────────────────────────────┐
│                 libhsakmt (ROCt Thunk Library)                │
│  ┌─────────────────────────────────────────────────────┐     │
│  │  User-Kernel Interface (用户-内核接口)               │     │
│  │  • ioctl封装                                         │     │
│  │  • 拓扑查询                                          │     │
│  │  • 内存操作                                          │     │
│  │  • 队列操作                                          │     │
│  └─────────────────────────────────────────────────────┘     │
│       rocr-runtime/libhsakmt - Thunk接口库                     │
└───────────────────────────────────────────────────────────────┘
                              │
                        ioctl系统调用
                              │
                              ▼
┌───────────────────────────────────────────────────────────────┐
│                  KFD (Kernel Fusion Driver)                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │ Process Mgmt │  │ Queue Mgmt   │  │ Memory Mgmt  │       │
│  │ (进程管理)    │  │ (队列管理)    │  │ (内存管理)    │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │ Doorbell     │  │ Interrupt    │  │ Topology     │       │
│  │ (门铃机制)    │  │ (中断处理)    │  │ (拓扑管理)    │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
│              kfd/amdkfd - Linux内核驱动                        │
└───────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌───────────────────────────────────────────────────────────────┐
│                      AMD GPU 硬件                             │
│  Compute Units │ Memory │ Command Processor │ SDMA Engines    │
└───────────────────────────────────────────────────────────────┘
```

## 2. 内核启动流程图

```
[应用代码]
    │
    │ hipLaunchKernel(kernel, grid, block, args, stream)
    ▼
[HIP Runtime - hipamd]
    │ 1. 验证参数
    │ 2. 获取kernel元数据
    │ 3. 准备kernel参数
    ▼
[ROCclr]
    │ 1. 创建NDRangeKernelCommand
    │ 2. 提交到CommandQueue
    │ 3. 构建AQL包
    │
    │ AQL Packet 结构:
    │ ┌─────────────────────────┐
    │ │ header (包类型、控制位)   │
    │ │ setup (维度信息)         │
    │ │ workgroup_size (x,y,z)  │
    │ │ grid_size (x,y,z)       │
    │ │ kernel_object (代码地址) │
    │ │ kernarg_address (参数)  │
    │ │ completion_signal (信号)│
    │ └─────────────────────────┘
    ▼
[HSA Runtime]
    │ 1. write_idx = queue.add_write_index()
    │ 2. 填充AQL包到队列
    │ 3. 写入Doorbell寄存器
    │
    │ Queue Ring Buffer:
    │ ┌─────┬─────┬─────┬─────┬─────┐
    │ │ AQL │ AQL │ AQL │ AQL │ ... │
    │ └─────┴─────┴─────┴─────┴─────┘
    │   ↑read_idx      ↑write_idx
    ▼
[Doorbell 写入]
    │ *doorbell_ptr = write_idx
    │ (MMIO写入，无系统调用！)
    ▼
[GPU Command Processor]
    │ 1. 检测到Doorbell
    │ 2. 从队列读取AQL包
    │ 3. 解析包
    │ 4. 调度到Compute Units
    ▼
[GPU Compute Units]
    │ 1. 执行kernel
    │ 2. 完成后更新completion_signal
    ▼
[应用/Runtime同步]
    │ 等待signal或轮询
    └─> 完成
```

## 3. 内存分配流程图

```
[应用]
    │ hipMalloc(&ptr, size)
    ▼
[HIP Runtime]
    │ ihipMalloc()
    ▼
[ROCclr]
    │ amd::Device::createMemory()
    │ roc::Memory::create()
    ▼
[HSA Runtime]
    │ hsa_amd_memory_pool_allocate()
    │
    │ 选择内存池:
    │ ┌──────────────────────┐
    │ │ VRAM (GPU Local)     │ ← 最快
    │ │ GTT (System pinned)  │
    │ │ System (Pageable)    │
    │ └──────────────────────┘
    ▼
[libhsakmt]
    │ hsaKmtAllocMemory()
    │ ioctl(AMDKFD_IOC_ALLOC_MEMORY_OF_GPU)
    ▼
[KFD Driver]
    │ kfd_ioctl_alloc_memory_of_gpu()
    │ ├─> amdgpu_amdkfd_gpuvm_alloc_memory()
    │ ├─> 分配GPU页表
    │ ├─> 映射到进程VA空间
    │ └─> 返回GPU VA地址
    ▼
[返回路径]
    KFD → libhsakmt → HSA → ROCclr → HIP → 应用
    (ptr 包含GPU虚拟地址)
```

## 4. 内存类型与访问模式

```
┌─────────────────────────────────────────────────────────┐
│                    内存层次结构                          │
└─────────────────────────────────────────────────────────┘

CPU Side                           GPU Side
┌──────────────┐                  ┌──────────────┐
│ System RAM   │                  │ VRAM (HBM)   │
│ (DDR4/5)     │◄────┐     ┌─────►│ GPU Local    │
└──────────────┘     │     │      └──────────────┘
      ▲              │     │             ▲
      │              │     │             │
      │         ┌────┴─────┴────┐       │
      │         │   PCIe Bus     │       │
      │         │  (16-32 GB/s)  │       │
      │         └────────────────┘       │
      │                                  │
      │                                  │
┌─────┴──────────────────────────────────┴─────┐
│           统一虚拟地址空间 (SVM)               │
│  CPU和GPU可以访问相同虚拟地址                 │
│  • 自动页面迁移                               │
│  • 页错误处理                                 │
│  • KFD驱动管理                                │
└──────────────────────────────────────────────┘

内存类型特性:
┌─────────────┬──────────┬──────────┬────────────┐
│  内存类型    │ CPU访问  │ GPU访问  │   延迟      │
├─────────────┼──────────┼──────────┼────────────┤
│ VRAM        │ 慢       │ 最快     │ ~100ns     │
│ GTT         │ 快       │ 中等     │ ~500ns     │
│ System      │ 最快     │ 慢       │ ~1us       │
│ SVM         │ 动态迁移  │ 动态迁移 │ 首次访问慢 │
└─────────────┴──────────┴──────────┴────────────┘
```

## 5. 队列与Doorbell机制

```
┌──────────────────────────────────────────────────────┐
│                 用户空间进程                          │
│                                                       │
│  HSA Runtime:                                        │
│  1. 获取队列写入索引                                  │
│     write_idx = atomic_fetch_add(&queue->write_idx)  │
│                                                       │
│  2. 计算队列槽位                                      │
│     slot = write_idx % queue_size                    │
│                                                       │
│  3. 填充AQL包                                        │
│     queue->buffer[slot] = aql_packet                 │
│                                                       │
│  4. 写入Doorbell (关键！)                            │
│     *doorbell_ptr = write_idx  ◄──┐                 │
│     (直接MMIO写入，无系统调用)      │                 │
└────────────────────────────────────┼─────────────────┘
                                     │
                        映射到用户空间的MMIO区域
                                     │
┌────────────────────────────────────┼─────────────────┐
│                 内核空间 (KFD)      │                 │
│                                     │                 │
│  Doorbell Page Mapping:            │                 │
│  • 每个队列一个独立的doorbell       │                 │
│  • mmap映射到用户空间               │                 │
│  • 用户可直接写入                   │                 │
│                                     │                 │
└────────────────────────────────────┼─────────────────┘
                                     │
                              硬件监控Doorbell
                                     │
┌────────────────────────────────────▼─────────────────┐
│                   GPU 硬件                            │
│                                                       │
│  Command Processor:                                  │
│  1. 监控doorbell寄存器                               │
│  2. 检测到变化 → 从队列读取AQL包                     │
│  3. 解析包 → 调度到计算单元                          │
│                                                       │
│  队列环形缓冲区 (在GPU可见内存中):                    │
│  ┌─────┬─────┬─────┬─────┬─────┬─────┐             │
│  │ AQL │ AQL │ AQL │ AQL │ AQL │ ... │             │
│  └─────┴─────┴─────┴─────┴─────┴─────┘             │
│    ↑                         ↑                      │
│  read_idx                 write_idx                 │
│  (GPU维护)                (用户态写入)                │
└──────────────────────────────────────────────────────┘

性能对比:
┌────────────────────┬──────────────┬─────────────┐
│     提交方式        │    延迟      │   吞吐量    │
├────────────────────┼──────────────┼─────────────┤
│ 传统ioctl方式      │ ~1-2 μs      │ 低          │
│ Doorbell机制       │ ~100 ns      │ 非常高      │
└────────────────────┴──────────────┴─────────────┘
```

## 6. KFD驱动核心模块交互图

```
┌─────────────────────────────────────────────────────────────┐
│                      KFD Driver (kfd/amdkfd)                │
│                                                              │
│  ┌──────────────┐                                           │
│  │ kfd_chardev  │  /dev/kfd字符设备                          │
│  │   (ioctl)    │  处理所有用户态请求                         │
│  └──────┬───────┘                                           │
│         │                                                    │
│         ├──────────┬──────────┬──────────┬──────────────┐  │
│         ▼          ▼          ▼          ▼              ▼  │
│  ┌──────────┐ ┌────────┐ ┌────────┐ ┌──────────┐ ┌──────┐│
│  │kfd_process│ │kfd_queue│ │kfd_memory│ │kfd_events│ │kfd_│││
│  │  (进程)   │ │ (队列)  │ │ (内存)  │ │ (事件)   │ │debug│││
│  └─────┬────┘ └───┬────┘ └───┬────┘ └─────┬────┘ └──┬───┘│
│        │          │          │            │          │    │
│        └──────────┴──────────┴────────────┴──────────┘    │
│                           │                                │
│                           ▼                                │
│            ┌──────────────────────────┐                    │
│            │   kfd_device_queue_mgr   │                    │
│            │   (设备队列管理器)        │                    │
│            │   • 调度队列              │                    │
│            │   • 管理MQD               │                    │
│            │   • 硬件寄存器配置         │                    │
│            └────────────┬─────────────┘                    │
│                         │                                  │
│                         ▼                                  │
│            ┌────────────────────────┐                      │
│            │   amdgpu_amdkfd API    │                      │
│            │   (与AMDGPU驱动交互)    │                      │
│            └────────────┬───────────┘                      │
│                         │                                  │
└─────────────────────────┼──────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                    AMDGPU Driver                            │
│  • GPU初始化和配置                                           │
│  • 页表管理                                                  │
│  • 硬件访问                                                  │
└─────────────────────────────────────────────────────────────┘
```

## 7. 完整的数据流图（内核启动）

```
Time
 │
 │  [User Space]
 │  ┌────────────────────────────────────────────┐
 0ms│ hipLaunchKernel()                          │
 │  └────────────┬───────────────────────────────┘
 │               │ HIP API调用
 │               ▼
 │  ┌────────────────────────────────────────────┐
 │  │ HIP Runtime处理                            │
 │  │ • 参数验证                                 │
~1μs│ • 获取kernel元数据                         │
 │  └────────────┬───────────────────────────────┘
 │               │
 │               ▼
 │  ┌────────────────────────────────────────────┐
 │  │ ROCclr构建AQL包                            │
~2μs│ • NDRangeCommand                           │
 │  │ • 填充grid/block尺寸                       │
 │  └────────────┬───────────────────────────────┘
 │               │
 │               ▼
 │  ┌────────────────────────────────────────────┐
 │  │ HSA Runtime提交                            │
~3μs│ • 获取队列write_index                      │
 │  │ • 写入AQL包到队列                          │
 │  │ • 写入Doorbell ◄─ 关键步骤                 │
 │  └────────────┬───────────────────────────────┘
 │               │ Doorbell写入（~100ns）
 │               │ [无系统调用！]
 │               │
 │  [Hardware]   │
 │               ▼
 │  ┌────────────────────────────────────────────┐
 │  │ GPU Command Processor                      │
~3μs│ • 检测Doorbell变化                         │
 │  │ • 读取AQL包                                │
 │  └────────────┬───────────────────────────────┘
 │               │
 │               ▼
 │  ┌────────────────────────────────────────────┐
 │  │ GPU调度器                                  │
~4μs│ • 分配Compute Units                        │
 │  │ • 加载kernel代码                           │
 │  └────────────┬───────────────────────────────┘
 │               │
 │               ▼
 │  ┌────────────────────────────────────────────┐
 │  │ Compute Units执行                          │
 ?ms │ • 运行wavefronts                           │
 │  │ • 访问VRAM                                 │
 │  └────────────┬───────────────────────────────┘
 │               │
 │               ▼
 │  ┌────────────────────────────────────────────┐
 │  │ GPU完成                                    │
 │  │ • 更新completion_signal                    │
 │  │ • 可选触发中断                             │
 │  └────────────┬───────────────────────────────┘
 │               │
 │  [User Space] │
 │               ▼
 │  ┌────────────────────────────────────────────┐
 │  │ HSA Runtime/应用                           │
 │  │ • 轮询或等待signal                         │
 │  │ • hipStreamSynchronize()                   │
 │  └────────────────────────────────────────────┘
 ▼
```

## 8. 组件间接口汇总

```
┌──────────────┬────────────────────┬─────────────────────────┐
│   层级       │   接口类型         │    主要函数/调用         │
├──────────────┼────────────────────┼─────────────────────────┤
│ HIP          │ C++ API            │ hipMalloc()             │
│   ↓          │                    │ hipMemcpy()             │
│ ROCclr       │                    │ hipLaunchKernel()       │
│              │ C++对象接口        │ amd::Command::enqueue() │
│              │                    │ amd::Device::create*()  │
├──────────────┼────────────────────┼─────────────────────────┤
│ ROCclr       │ 动态加载           │ dlopen("libhsa-...")    │
│   ↓          │ C函数指针          │ Hsa::hsa_init()         │
│ HSA Runtime  │                    │ Hsa::queue_create()     │
│              │ C API              │ hsa_memory_allocate()   │
│              │                    │ hsa_signal_wait()       │
├──────────────┼────────────────────┼─────────────────────────┤
│ HSA Runtime  │ 直接链接           │ hsaKmtOpenKFD()         │
│   ↓          │ C API              │ hsaKmtAllocMemory()     │
│ libhsakmt    │                    │ hsaKmtCreateQueue()     │
│              │                    │ hsaKmtMapMemoryToGPU()  │
├──────────────┼────────────────────┼─────────────────────────┤
│ libhsakmt    │ ioctl系统调用      │ ioctl(kfd_fd,           │
│   ↓          │                    │   AMDKFD_IOC_CREATE_Q,  │
│ KFD          │                    │   &args)                │
│              │ /dev/kfd设备文件   │ open("/dev/kfd")        │
│              │                    │ mmap(doorbell)          │
├──────────────┼────────────────────┼─────────────────────────┤
│ KFD          │ 内核API            │ amdgpu_amdkfd_*()       │
│   ↓          │                    │ (KFD调用AMDGPU函数)      │
│ AMDGPU       │                    │                         │
└──────────────┴────────────────────┴─────────────────────────┘

特殊通道:
┌──────────────┬────────────────────┬─────────────────────────┐
│ 用户态       │ Doorbell (MMIO)    │ *doorbell_ptr = value   │
│   ↓          │ 直接写入           │ (无系统调用!)            │
│ GPU硬件      │                    │                         │
└──────────────┴────────────────────┴─────────────────────────┘
```

## 9. 关键性能指标

```
操作延迟对比:
┌──────────────────────────┬────────────┬─────────────┐
│        操作               │   延迟     │   说明      │
├──────────────────────────┼────────────┼─────────────┤
│ Doorbell写入             │ ~100 ns    │ MMIO写入    │
│ 系统调用 (ioctl)         │ ~1-2 μs    │ 上下文切换  │
│ AQL包提交                │ ~100 ns    │ 内存写入    │
│ Kernel启动延迟           │ ~3-5 μs    │ 端到端      │
│ PCIe数据传输 (16GB/s)    │ ~62.5ns/KB │ 带宽限制    │
│ GPU内存访问 (HBM)        │ ~100 ns    │ VRAM延迟    │
│ 跨GPU通信 (XGMI)         │ ~500 ns    │ 点对点      │
└──────────────────────────┴────────────┴─────────────┘

内存带宽:
┌──────────────────────────┬──────────────┐
│        路径               │    带宽      │
├──────────────────────────┼──────────────┤
│ GPU HBM (VRAM)           │ 1-2 TB/s     │
│ PCIe 4.0 x16             │ ~32 GB/s     │
│ PCIe 5.0 x16             │ ~64 GB/s     │
│ XGMI (Infinity Fabric)   │ 200+ GB/s    │
│ System DDR4              │ ~50 GB/s     │
└──────────────────────────┴──────────────┘
```

## 10. 常见优化模式

```
模式1: 异步执行
┌────────────────────────────────────────┐
│ hipMemcpyAsync(H→D, stream1)           │ ────┐
│ hipLaunchKernel(kernel, stream1)       │     ├─ 并行
│ hipMemcpyAsync(D→H, stream1)           │ ────┘
│                                        │
│ // CPU可以立即继续执行                 │
│ do_cpu_work();                         │
│                                        │
│ // 最后同步                            │
│ hipStreamSynchronize(stream1);         │
└────────────────────────────────────────┘

模式2: 多流并发
┌────────────────────────────────────────┐
│ hipMemcpyAsync(..., stream1) ──┐       │
│ hipLaunchKernel(..., stream1)  │       │
│                                ├─ 并发  │
│ hipMemcpyAsync(..., stream2) ──┤       │
│ hipLaunchKernel(..., stream2)  │       │
│                                │       │
│ hipDeviceSynchronize();        │       │
└────────────────────────────────┘───────┘

模式3: Unified Memory (自动迁移)
┌────────────────────────────────────────┐
│ hipMallocManaged(&ptr, size);          │
│                                        │
│ // CPU初始化数据                       │
│ for(i=0; i<n; i++) ptr[i] = i;        │
│   ↓ 页错误触发迁移到CPU                │
│                                        │
│ // GPU处理数据                         │
│ kernel<<<...>>>(ptr);                  │
│   ↓ 页错误触发迁移到GPU                │
│                                        │
│ // CPU读取结果                         │
│ printf("%d", ptr[0]);                  │
│   ↓ 页错误触发迁移回CPU                │
└────────────────────────────────────────┘
```

---

## 总结

这些图示展示了AMD ROCm软件栈的关键架构特性：

1. **清晰的分层设计**：每层职责明确，接口规范
2. **高性能机制**：Doorbell、用户态队列、零拷贝
3. **灵活的内存模型**：支持多种内存类型和访问模式
4. **标准化接口**：遵循HSA标准，保证可移植性
5. **完整的生态系统**：从应用层到硬件的全栈支持

这个架构使AMD GPU能够高效支持各种高性能计算和AI工作负载。

