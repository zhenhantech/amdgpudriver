# 新旧方案实施对比与决策指南

**日期**: 2026-02-04  
**目的**: 对比传统方案vs基于Map/Unmap的新方案，提供决策依据

**⚠️ 重要**: 本文档基于MI308X CPSCH模式（enable_mes=0）

---

## 📊 两种方案全面对比

### 方案对比表

| 维度 | 传统方案<br/>(suspend_queues API) | 新方案<br/>(Map/Unmap优化) | 决策建议 |
|------|----------------------------------|---------------------------|---------|
| **性能** | | | |
| Suspend延迟 | 5ms | 0.5ms | ⭐⭐⭐⭐⭐ 新方案10倍快 |
| Resume延迟 | 10ms | 0.5ms | ⭐⭐⭐⭐⭐ 新方案20倍快 |
| 批量操作(10队列) | 150ms | 1ms | ⭐⭐⭐⭐⭐ 新方案150倍快 |
| Online端到端 | 15-20ms | 1-2ms | ⭐⭐⭐⭐⭐ 新方案10倍快 |
| **资源利用** | | | |
| HQD利用率 | 60-70% | 85-90% | ⭐⭐⭐⭐ 新方案更高 |
| 超额订阅 | ❌ 不支持 | ✅ 支持 | ⭐⭐⭐⭐⭐ 新方案灵活 |
| Online资源保证 | ❌ 无保证 | ✅ 预留10% | ⭐⭐⭐⭐ 新方案稳定 |
| Offline队列数上限 | 30/GPU | 60+/GPU | ⭐⭐⭐⭐ 新方案2倍 |
| **实施复杂度** | | | |
| 内核修改 | ❌ 不需要 | ✅ 需要~400行 | ⚠️ 传统方案更简单 |
| 用户空间代码 | ~500行 | ~1200行 | ⚠️ 传统方案更少 |
| 开发时间 | 1周 | 2周 | ⚠️ 传统方案更快 |
| DKMS重编译 | ❌ 不需要 | ✅ 需要 | ⚠️ 传统方案无风险 |
| **调试和维护** | | | |
| 调试难度 | ⭐ 低 | ⭐⭐⭐ 中 | ⚠️ 传统方案更易调试 |
| 稳定性风险 | ⭐ 低 | ⭐⭐ 中 | ⚠️ 传统方案更稳定 |
| 代码复用率 | 0%（纯用户空间） | 80%（复用KFD） | ⭐⭐⭐⭐ 新方案复用多 |
| **功能** | | | |
| 基本抢占 | ✅ | ✅ | ⭐ 都支持 |
| 批量抢占 | ✅ 但慢 | ✅ 快 | ⭐⭐⭐⭐⭐ 新方案优 |
| 资源监控 | ❌ 无 | ✅ 实时 | ⭐⭐⭐⭐ 新方案有 |
| 动态调整 | ❌ 无 | ✅ 有 | ⭐⭐⭐⭐ 新方案灵活 |
| **未来扩展** | | | |
| 升级到Stage 2 | ⚠️ 需要重写 | ✅ 平滑 | ⭐⭐⭐⭐ 新方案可扩展 |
| 生产化 | ⚠️ 需要大改 | ✅ 渐进 | ⭐⭐⭐⭐ 新方案更接近 |

---

## 🎯 决策矩阵

### 什么时候选传统方案？

```
✅ 场景1: 快速概念验证
  - 时间紧张（<1周）
  - 只需要证明抢占可行
  - 不关心性能
  
✅ 场景2: 最小化风险
  - 不能修改内核
  - 稳定性优先
  - POC阶段的快速试错

✅ 场景3: 单队列场景
  - Offline只有1-2个队列
  - 不需要批量操作
  - 延迟15ms可接受
```

### 什么时候选新方案？⭐⭐⭐⭐⭐

```
✅ 场景1: 性能要求高
  - Online延迟需要<5ms
  - 批量操作频繁
  - 需要接近生产的性能

✅ 场景2: 多队列场景
  - Offline有10+个队列
  - 需要批量suspend/resume
  - 传统方案太慢（150ms）

✅ 场景3: 资源紧张
  - GPU负载高
  - HQD资源紧张
  - 需要预留和超额订阅

✅ 场景4: 长期项目
  - 准备升级到Stage 2/3
  - 需要积累性能数据
  - 可以投入2周开发
```

---

## 💡 推荐决策流程

### 决策树

```
                开始POC
                  │
                  ↓
        ┌─────────────────┐
        │ 时间和风险评估   │
        └─────────┬───────┘
                  │
    ┌─────────────┴─────────────┐
    │                           │
    ↓                           ↓
 时间<1周                    时间>=2周
 风险敏感                    可以修改内核
    │                           │
    ↓                           ↓
┌─────────┐              ┌─────────────┐
│传统方案  │              │ 再次评估性能 │
│         │              │ 要求        │
│suspend_ │              └──────┬──────┘
│queues   │                     │
└─────────┘      ┌──────────────┴──────────────┐
                 │                              │
                 ↓                              ↓
          Online延迟<10ms                Online延迟>10ms
          是硬性要求                      可接受15ms
                 │                              │
                 ↓                              ↓
          ┌─────────────┐              ┌─────────────┐
          │ 新方案       │              │ 传统方案     │
          │ (Map/Unmap) │              │ (快速验证)  │
          │             │              │ 后续可升级   │
          │ 直接实施     │              └─────────────┘
          │ 2周开发      │
          └─────────────┘
```

---

## 📋 详细决策准则

### 准则1: 性能要求

```
如果需要满足：
  ✅ Online延迟 < 5ms
  ✅ Offline吞吐量损失 < 10%
  ✅ 支持高频抢占（>10次/秒）

→ 选择新方案 ⭐⭐⭐⭐⭐

如果可以接受：
  ⚠️ Online延迟 < 50ms
  ⚠️ Offline吞吐量损失 < 20%
  ⚠️ 抢占频率 < 5次/秒

→ 传统方案足够 ⭐⭐⭐
```

### 准则2: 资源需求

```
如果场景包含：
  ✅ 多个Offline模型（10+队列）
  ✅ GPU资源紧张
  ✅ 需要超额订阅

→ 选择新方案 ⭐⭐⭐⭐⭐

如果场景是：
  ⚠️ 单个或少量Offline模型（<5队列）
  ⚠️ GPU资源充足
  ⚠️ HQD利用率<50%

→ 传统方案足够 ⭐⭐⭐
```

### 准则3: 项目时间线

```
如果时间线是：
  ✅ 可以投入2-3周
  ✅ 准备长期维护
  ✅ 后续升级到Stage 2/3

→ 选择新方案 ⭐⭐⭐⭐⭐

如果时间线是：
  ⚠️ 必须1周内完成
  ⚠️ 只是概念验证
  ⚠️ 后续可能不继续

→ 传统方案 ⭐⭐⭐⭐
```

### 准则4: 技术能力

```
如果团队具备：
  ✅ 内核开发经验
  ✅ KFD代码熟悉
  ✅ 可以调试内核问题

→ 选择新方案 ⭐⭐⭐⭐⭐

如果团队是：
  ⚠️ 只有用户空间经验
  ⚠️ 不熟悉KFD内核
  ⚠️ 调试内核困难

→ 传统方案 ⭐⭐⭐⭐
```

---

## 🚀 推荐的实施路线图

### 路线A: 渐进式（最低风险）⭐⭐⭐⭐⭐

```
┌─────────────────────────────────────┐
│ Week 1-2: 传统方案POC                │
│ ───────────────────────────────────  │
│ 使用suspend_queues API              │
│ 纯用户空间代码                       │
│ 目标：验证概念                       │
│                                      │
│ 交付：                               │
│  ✅ 概念验证通过                     │
│  ✅ Baseline性能数据                 │
│  ✅ 发现的问题清单                   │
└─────────────────────────────────────┘
              ↓ 评估结果
         ┌─────────┴─────────┐
         │                   │
         ↓                   ↓
     性能满足             性能不满足
    (<50ms)              (>50ms)
         │                   │
         ↓                   ↓
  ┌────────────┐     ┌─────────────────────┐
  │ 直接使用    │     │ Week 3-4: 新方案     │
  │ 传统方案    │     │ ─────────────────── │
  │            │     │ 实施Map/Unmap优化   │
  │ 完成POC ✓  │     │ 目标：延迟<5ms      │
  └────────────┘     │                     │
                     │ 交付：              │
                     │  ✅ 性能优化版本    │
                     │  ✅ 延迟<5ms        │
                     │  ✅ 完整测试报告    │
                     └─────────────────────┘

优点：
  ✅ 风险最低（传统方案失败也只浪费1周）
  ✅ 渐进式（有baseline对比）
  ✅ 可以提前交付部分成果

推荐指数：⭐⭐⭐⭐⭐（最推荐）
```

### 路线B: 直接新方案（激进）⭐⭐⭐⭐

```
┌─────────────────────────────────────┐
│ Week 1: 内核开发                     │
│ ───────────────────────────────────  │
│ 新增3个ioctl                         │
│ 实现batch_unmap + fast_remap        │
│ 内核测试和调试                       │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│ Week 2: 用户空间开发                 │
│ ───────────────────────────────────  │
│ libgpreempt_poc_v2.so               │
│ SmartQueueScheduler                 │
│ 完整测试                             │
└─────────────────────────────────────┘
              ↓
      性能目标达成
      延迟<5ms ✓

优点：
  ✅ 最终性能最好
  ✅ 一次到位
  ✅ 数据更有价值

缺点：
  ⚠️ 如果失败，浪费2周
  ⚠️ 内核稳定性风险
  ⚠️ 无法提前交付

推荐指数：⭐⭐⭐⭐（如果有充足时间和技术能力）
```

### 路线C: 混合方案（平衡）⭐⭐⭐⭐

```
┌─────────────────────────────────────┐
│ Week 1: 并行开发                     │
│ ───────────────────────────────────  │
│ Team A: 传统方案（用户空间）         │
│ Team B: 新方案内核接口               │
│                                      │
│ Week 1结束时：                       │
│  • Team A交付：传统方案可运行         │
│  • Team B交付：内核接口基本完成       │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│ Week 2: 集成和测试                   │
│ ───────────────────────────────────  │
│ • Team A测试传统方案                 │
│ • Team B完成新方案用户空间           │
│ • 对比测试两种方案                   │
│ • 根据结果选择最优方案               │
└─────────────────────────────────────┘

优点：
  ✅ 双保险（两种方案都有）
  ✅ 可以对比性能
  ✅ 风险分散

缺点：
  ⚠️ 需要2个人或更多时间

推荐指数：⭐⭐⭐⭐（如果有2人团队）
```

---

## 🎯 基于不同目标的推荐

### 目标1: "快速验证概念，1周完成"

**推荐**: 传统方案 ⭐⭐⭐⭐⭐

```
实施路径：
  Day 1-2: libgpreempt_poc.so (suspend/resume封装)
  Day 3:   MQD解析 + Queue ID获取
  Day 4:   Python Test Framework
  Day 5:   基本测试

交付：
  ✅ 概念验证
  ✅ 基本功能测试
  ✅ Baseline性能数据
```

---

### 目标2: "性能是关键，延迟必须<5ms"

**推荐**: 新方案 ⭐⭐⭐⭐⭐

```
实施路径：
  Week 1: 内核开发（batch_unmap + fast_remap）
  Week 2: 用户空间 + 测试

交付：
  ✅ 延迟<5ms（目标达成）
  ✅ 完整性能测试
  ✅ 可扩展架构
```

---

### 目标3: "需要支持10+个Offline队列"

**推荐**: 新方案 ⭐⭐⭐⭐⭐

```
原因：
  传统方案批量操作：10队列 × 15ms = 150ms ❌
  新方案批量操作：1ms ✅

差距：150倍
```

---

### 目标4: "平衡性能和风险"

**推荐**: 渐进式（路线A）⭐⭐⭐⭐⭐

```
Week 1-2: 传统方案
  → 快速交付
  → 降低风险
  
Week 3-4: 如果需要，升级到新方案
  → 基于实际需求
  → 有baseline对比
```

---

## 📊 ROI (投资回报) 分析

### 传统方案 ROI

```
投入：
  - 开发时间：1周
  - 人力：1人
  - 代码量：~500行
  - 风险：低
  ─────────────
  总投入：1人周

产出：
  - 概念验证：✅
  - 性能：一般（15ms）
  - 可扩展性：低
  - 生产价值：低
  ─────────────
  ROI：中等

适合：快速验证阶段
```

### 新方案 ROI

```
投入：
  - 开发时间：2周
  - 人力：1-2人
  - 代码量：~1600行（但80%复用）
  - 风险：中
  ─────────────
  总投入：2-3人周

产出：
  - 概念验证：✅
  - 性能：优秀（1ms）⭐⭐⭐⭐⭐
  - 可扩展性：高 ⭐⭐⭐⭐⭐
  - 生产价值：高 ⭐⭐⭐⭐
  ─────────────
  ROI：高

适合：长期项目，需要高性能
```

---

## 🔄 迁移路径分析

### 从传统方案迁移到新方案

```
如果Week 1-2实施了传统方案：

可复用的：
  ✅ MQD解析代码（90%）
  ✅ Test Framework结构（80%）
  ✅ AI模型包装（100%）
  ✅ 测试用例（70%）

需要重写的：
  ⚠️ C库接口（调用新ioctl）
  ⚠️ 调度逻辑（批量操作）
  ⚠️ 内核接口（新增）

迁移成本：约5天（50%的开发时间）

总结：
  传统方案 → 新方案的迁移成本：5天
  直接新方案的开发成本：10天
  
  差别：只多5天，但有fallback保证 ✓
```

### 从新方案到Stage 2/3

```
如果实施了新方案：

到Stage 2（CWSR直接使用）：
  ✅ 已经熟悉Map/Unmap机制
  ✅ 已经有HQD资源管理
  ✅ 可以直接调用pqm_checkpoint_mqd
  
  迁移成本：约5天

到Stage 3（内核态调度器）：
  ✅ 已经有内核接口经验
  ✅ 已经有资源监控
  ✅ 可以平滑集成
  
  迁移成本：约10-15天

新方案是更好的跳板！⭐⭐⭐⭐⭐
```

---

## 💰 成本效益分析

### 场景1: 单次POC，不继续开发

```
传统方案：
  成本：1周
  效益：概念验证
  价值：中
  推荐：⭐⭐⭐⭐⭐

新方案：
  成本：2周
  效益：概念验证 + 高性能
  价值：中-高
  推荐：⭐⭐⭐
  
结论：传统方案更经济
```

### 场景2: POC后继续到Stage 2

```
路径A（传统→新→Stage2）：
  传统方案：1周
  升级新方案：5天
  到Stage 2：5天
  ───────────────
  总计：3周 + 一些返工

路径B（直接新→Stage2）：
  新方案：2周
  到Stage 2：5天
  ───────────────
  总计：2.5周

节省：0.5周
推荐：路径B ⭐⭐⭐⭐⭐
```

### 场景3: 最终到Production

```
路径A（传统→新→Stage2→Stage3）：
  传统：1周
  新方案：5天
  Stage 2：5天
  Stage 3：1月
  ───────────────
  总计：~2月 + 多次返工 ⚠️

路径B（直接新→Stage2→Stage3）：
  新方案：2周
  Stage 2：5天
  Stage 3：1月
  ───────────────
  总计：~1.5月 ✅

节省：2周 + 减少返工
推荐：路径B ⭐⭐⭐⭐⭐
```

---

## 🎓 我的推荐（基于不同角色）

### 如果你是：项目经理

**推荐**: 渐进式（路线A）⭐⭐⭐⭐⭐

```
原因：
  ✅ 风险最低
  ✅ 可以提前交付部分成果
  ✅ 投资者看到进展
  ✅ 失败成本最小

决策：
  Week 1-2: 传统方案
  Week 3: 评审和决策
  Week 4+: 根据需要升级
```

### 如果你是：技术负责人

**推荐**: 新方案（路线B）⭐⭐⭐⭐⭐

```
原因：
  ✅ 最终目标是高性能
  ✅ 传统方案只是过渡
  ✅ 避免返工
  ✅ 技术深度更好

决策：
  Week 1-2: 新方案完整实施
  数据更有参考价值
  更接近生产需求
```

### 如果你是：研究员/实习生

**推荐**: 传统方案 ⭐⭐⭐⭐⭐

```
原因：
  ✅ 学习曲线平缓
  ✅ 成功概率高
  ✅ 1周看到结果（成就感）
  ✅ 风险低（不会搞坏系统）

决策：
  专注用户空间代码
  快速验证和学习
  后续可以升级
```

### 如果你是：性能工程师

**推荐**: 直接新方案 ⭐⭐⭐⭐⭐

```
原因：
  ✅ 对Map/Unmap机制有深入理解
  ✅ 需要精确的性能数据
  ✅ 传统方案的数据参考价值低
  ✅ 可以接受内核开发

决策：
  直接实施新方案
  收集详细性能数据
  为Stage 2/3做准备
```

---

## 📈 风险评估

### 传统方案风险

| 风险 | 概率 | 影响 | 应对 |
|------|------|------|------|
| API不可用 | 低 | 高 | 提前测试API |
| 性能不满足 | 中 | 中 | 可升级到新方案 |
| 队列识别困难 | 低 | 中 | 多种备选方案 |
| 稳定性问题 | 低 | 低 | 纯用户空间，易恢复 |

**总体风险**: 低 ✅

### 新方案风险

| 风险 | 概率 | 影响 | 应对 |
|------|------|------|------|
| 内核编译失败 | 低 | 高 | 充分测试环境 |
| 新ioctl不稳定 | 中 | 高 | 充分测试，保留fallback |
| HQD预留策略bug | 中 | 中 | 可关闭预留，降级使用 |
| 性能未达预期 | 低 | 中 | 已有理论支撑 |
| 破坏现有功能 | 低 | 高 | 充分回归测试 |

**总体风险**: 中 ⚠️

**风险缓解**:
1. 先在测试GPU测试
2. 保留传统方案作为fallback
3. 充分的单元测试和集成测试
4. 逐步rollout（先1个GPU，再8个）

---

## 🎯 最终推荐

### 我的推荐：渐进式路线A ⭐⭐⭐⭐⭐

**理由**：

```
1. 风险最低 ✅
   - 传统方案失败只浪费1周
   - 新方案基于传统方案的经验
   - 有清晰的milestone

2. 可以提前交付 ✅
   - Week 2就能看到成果
   - 满足项目进度要求
   - 给stakeholder信心

3. 性能优化有针对性 ✅
   - 知道瓶颈在哪
   - 优化方向明确
   - 有baseline对比

4. 学习曲线友好 ✅
   - 从简单到复杂
   - 逐步理解Map/Unmap
   - 更容易掌握

5. 灵活性高 ✅
   - 可以在Week 2后决定是否升级
   - 如果传统方案满足，可以不升级
   - 节省不必要的开发
```

**实施建议**：

```
┌──────────────────────────────────────┐
│ Week 1-2: 传统方案POC                 │
│ 目标：验证可行性 + 收集性能数据        │
└──────────────────────────────────────┘
                ↓
        ┌───────────────┐
        │ Week 2 评审会  │
        └───────┬───────┘
                │
      ┌─────────┴─────────┐
      │                   │
      ↓                   ↓
  性能满足            性能不满足
   (<50ms)             (>50ms)
      │                   │
      ↓                   ↓
  ┌────────┐       ┌──────────────┐
  │ 完成   │       │ Week 3-4:    │
  │ POC ✓  │       │ 升级到新方案  │
  └────────┘       └──────────────┘
```

---

## 📋 实施Checklist

### 传统方案Checklist（Week 1-2）

- [ ] Day 1: API验证
  - [ ] 测试suspend_queues可用性
  - [ ] 测试resume_queues可用性
  - [ ] 权限检查

- [ ] Day 2: C库实现
  - [ ] libgpreempt_poc.so
  - [ ] suspend/resume封装
  - [ ] MQD解析

- [ ] Day 3: Queue ID获取
  - [ ] 暴力枚举实现
  - [ ] debugfs解析实现
  - [ ] 测试准确性

- [ ] Day 4: Python Framework
  - [ ] GPreemptScheduler类
  - [ ] AI模型包装
  - [ ] 测试主程序

- [ ] Day 5: 测试和数据收集
  - [ ] 功能测试
  - [ ] 性能测试
  - [ ] 数据分析

- [ ] **Week 2 评审**:
  - [ ] 性能是否满足？
  - [ ] 是否需要升级？
  - [ ] 决策：完成 or 继续

### 新方案Checklist（Week 3-4，如果需要）

- [ ] Day 6-7: 内核接口
  - [ ] BATCH_UNMAP_QUEUES ioctl
  - [ ] FAST_REMAP ioctl
  - [ ] SET_HQD_RESERVATION ioctl
  - [ ] 编译和基本测试

- [ ] Day 8: 内核集成
  - [ ] 集成到kfd_chardev.c
  - [ ] 测试各个接口
  - [ ] 回归测试

- [ ] Day 9: 用户空间升级
  - [ ] libgpreempt_poc_v2.so
  - [ ] SmartQueueScheduler
  - [ ] HQDResourceMonitor

- [ ] Day 10: 完整测试
  - [ ] 功能测试
  - [ ] 性能对比测试
  - [ ] 稳定性测试

- [ ] **Final评审**:
  - [ ] 性能提升达到预期？
  - [ ] 稳定性是否满足？
  - [ ] 是否值得继续到Stage 2？

---

## 🎯 关键决策点

### 决策点1: Week 0（现在）

**问题**: 选择哪条路线？

**建议**: 路线A（渐进式）⭐⭐⭐⭐⭐

**原因**:
1. 你刚完成Map/Unmap机制研究（知识储备充足）✅
2. 有2周时间可以投入 ✅
3. 想要高性能（目标明确）✅
4. 但也要控制风险 ✅

**决策**: 
- Week 1-2: 先做传统方案（降低风险）
- Week 2评审: 根据数据决定是否升级
- Week 3-4: 如果需要，实施新方案

---

### 决策点2: Week 2评审

**问题**: 传统方案性能是否满足？

**判断标准**:

```
如果满足以下所有条件，则完成POC：
  ✅ Online延迟 < 50ms
  ✅ Offline吞吐量损失 < 20%
  ✅ 系统稳定运行
  ✅ 功能测试全部通过

如果任一条件不满足，则升级到新方案：
  ⚠️ Online延迟 > 50ms  ← 最可能的情况
  ⚠️ 批量操作太慢
  ⚠️ 资源竞争导致不稳定
```

**预测**: 延迟很可能>50ms（基于分析），**会需要升级到新方案** ⭐

---

## 📊 数据驱动的决策

### 需要收集的数据（Week 1-2传统方案）

```
性能数据：
  1. Suspend延迟分布
     - 平均值
     - P50, P95, P99
     - 最大值
  
  2. Resume延迟分布
     - 同上
  
  3. Online端到端延迟
     - 包含suspend + online执行 + resume
  
  4. Offline吞吐量对比
     - Baseline（无抢占）
     - With抢占
     - 损失百分比

资源数据：
  1. HQD利用率
  2. MQD数量vs HQD数量
  3. 资源竞争情况

稳定性数据：
  1. 崩溃次数
  2. dmesg错误
  3. 长时间运行稳定性
```

### 决策阈值

```
如果数据显示：
  ✅ Suspend平均延迟 < 3ms  → 传统方案满足
  ⚠️ Suspend平均延迟 3-10ms → 考虑升级
  ❌ Suspend平均延迟 > 10ms  → 必须升级

  ✅ Online延迟 < 30ms       → 传统方案满足
  ⚠️ Online延迟 30-50ms     → 边缘情况，讨论
  ❌ Online延迟 > 50ms       → 必须升级

  ✅ Offline损失 < 10%       → 传统方案满足
  ⚠️ Offline损失 10-20%     → 可接受
  ❌ Offline损失 > 20%       → 必须升级或调整策略
```

---

## 🚦 行动建议总结

### 立即行动（Today）

```
1. 决定实施路线
   推荐：路线A（渐进式）
   
2. 开始Week 1
   实施：传统方案
   目标：快速验证
   
3. 准备评审
   Week 2结束时评审
   决定是否升级
```

### Week 2评审准备

```
准备材料：
  1. 性能测试报告
  2. 与目标的对比
  3. 升级成本评估
  4. 风险分析

决策依据：
  • 如果性能满足 → 完成POC
  • 如果性能不满足 → 升级到新方案
  • 数据说话，不凭感觉
```

---

## 📚 相关文档索引

### 必读文档

1. **New_DESIGN_MAP_UNMAP_BASED_PREEMPTION.md** - 新方案详细设计
2. **New_IMPLEMENTATION_COMPARISON.md** - 本文档
3. **ARCH_Design_01_POC_Stage1_实施方案.md** - 传统方案

### 背景知识

1. **SW_QUEUE_HW_QUEUE_MAPPING_MECHANISM.md** - Map/Unmap机制
2. **MAP_UNMAP_DETAILED_PROCESS.md** - 详细流程
3. **MAP_UNMAP_VISUAL_GUIDE.md** - 可视化指南

### 代码参考

1. **kfd_device_queue_manager.c** line 2442 - execute_queues_cpsch()
2. **kfd_device_queue_manager.c** line 777 - allocate_hqd()
3. **kfd_mqd_manager_v9.c** line 857 - load_mqd_v9_4_3()

---

**创建时间**: 2026-02-04  
**决策支持**: ⭐⭐⭐⭐⭐  
**推荐**: 渐进式路线A（先传统，后升级）  

**最终建议**: 从传统方案开始（Week 1-2），根据性能数据决定是否升级到新方案（Week 3-4）。这是风险最低、ROI最高的路径！✅
