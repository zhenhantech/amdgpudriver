# Map/Unmap可视化指南

**日期**: 2026-02-03  
**目的**: 用图表说明SW_queue到HW_queue的map/unmap过程

---

## 🎨 核心概念可视化

### MQD vs HQD

```
┌──────────────────────────────────────┐
│     系统内存 (System Memory)          │
│                                       │
│  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐    │
│  │MQD 1│ │MQD 2│ │MQD 3│ │MQD 4│ ...│  ← 软件队列
│  └─────┘ └─────┘ └─────┘ └─────┘    │     可以很多个
│     ↓                                 │     ~512 bytes/个
└────┼────────────────────────────────┘
     │
     │ Map操作: 加载到硬件
     ↓
┌──────────────────────────────────────┐
│       GPU Hardware (XCC 0)           │
│                                       │
│  MEC 0 (Compute):                    │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┐  │
│  │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │  │ ← Pipe 0
│  └───┴───┴───┴───┴───┴───┴───┴───┘  │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┐  │
│  │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │  │ ← Pipe 1
│  └───┴───┴───┴───┴───┴───┴───┴───┘  │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┐  │
│  │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │  │ ← Pipe 2
│  └───┴───┴───┴───┴───┴───┴───┴───┘  │
│  ┌───┬───┬───┬───┬───┬───┬───┬───┐  │
│  │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │  │ ← Pipe 3
│  └───┴───┴───┴───┴───┴───┴───┴───┘  │
│  4 Pipes × 8 Queues = 32个HQD       │
│  减去2个KCQ = 30个可用               │
└──────────────────────────────────────┘
```

---

## 🔄 Map操作可视化

### 场景：创建3个Active队列

```
用户: 创建3个stream
  ↓
步骤1: 分配MQD (系统内存)
┌────────────────────┐
│ 系统内存            │
│ ┌─────┐            │
│ │MQD 1│ ✓ 创建     │
│ └─────┘            │
│ ┌─────┐            │
│ │MQD 2│ ✓ 创建     │
│ └─────┘            │
│ ┌─────┐            │
│ │MQD 3│ ✓ 创建     │
│ └─────┘            │
└────────────────────┘

步骤2: 分配HQD槽位 (Round-robin)
GPU XCC 0:
  Pipe 0: [K][K][✓][░][░][░][░][░]
            ↑   ↑  ↑
            KCQ  MQD1
  Pipe 1: [✓][░][░][░][░][░][░][░]
           ↑
           MQD2
  Pipe 2: [✓][░][░][░][░][░][░][░]
           ↑
           MQD3
  Pipe 3: [░][░][░][░][░][░][░][░]
  
  分配结果:
    MQD 1 → (pipe=0, queue=2)
    MQD 2 → (pipe=1, queue=0)
    MQD 3 → (pipe=2, queue=0)

步骤3: Map到硬件 (4个XCC)
┌──────── XCC 0 ────────┐
│ HQD[0][2] ← MQD 1     │
│ HQD[1][0] ← MQD 2     │
│ HQD[2][0] ← MQD 3     │
└───────────────────────┘
┌──────── XCC 1 ────────┐
│ HQD[0][2] ← MQD 1     │ ← 同样的(pipe,queue)
│ HQD[1][0] ← MQD 2     │
│ HQD[2][0] ← MQD 3     │
└───────────────────────┘
┌──────── XCC 2 ────────┐
│ HQD[0][2] ← MQD 1     │
│ HQD[1][0] ← MQD 2     │
│ HQD[2][0] ← MQD 3     │
└───────────────────────┘
┌──────── XCC 3 ────────┐
│ HQD[0][2] ← MQD 1     │
│ HQD[1][0] ← MQD 2     │
│ HQD[2][0] ← MQD 3     │
└───────────────────────┘

结果:
  - 3个软件队列(MQD)
  - 12个物理HQD (3 × 4 XCC) ⭐
  - 3个逻辑HQD标识
```

---

## 🔄 Unmap操作可视化

### 场景：销毁1个队列

```
用户: hipStreamDestroy(stream2)
  ↓
步骤1: Unmap from HWS

发送Unmap packet:
  ┌──────────────────┐
  │  HIQ (MEC 2)     │
  │  ┌────────────┐  │
  │  │UNMAP_QUEUE │ ← Packet
  │  │pipe=1,q=0  │  │
  │  └────────────┘  │
  └──────────────────┘
         ↓
    HWS处理
         ↓
    
步骤2: 卸载HQD（4个XCC）

XCC 0:
  Before: [K][K][✓][░][░][░][░][░]  Pipe 0
          [✓][░][░][░][░][░][░][░]  Pipe 1 ← MQD 2
          [✓][░][░][░][░][░][░][░]  Pipe 2
          
  After:  [K][K][✓][░][░][░][░][░]  Pipe 0
          [░][░][░][░][░][░][░][░]  Pipe 1 ← 卸载！
          [✓][░][░][░][░][░][░][░]  Pipe 2

XCC 1-3: (同样卸载)

步骤3: 释放资源

allocated_queues[1] |= (1 << 0)
  Before: 0b11111110  (Queue 0占用)
  After:  0b11111111  (Queue 0空闲) ✓

释放MQD:
┌────────────────────┐
│ 系统内存            │
│ ┌─────┐            │
│ │MQD 1│ ✓ 保留     │
│ └─────┘            │
│ ┌─────┐            │
│ │MQD 2│ ✗ 释放     │ ← Free
│ └─────┘            │
│ ┌─────┐            │
│ │MQD 3│ ✓ 保留     │
│ └─────┘            │
└────────────────────┘

结果:
  - MQD: 从3个减到2个
  - HQD: 从12个减到8个
  - (pipe=1, queue=0)可用于新队列 ✓
```

---

## 📈 Runlist机制可视化

### Runlist IB的构建

```
所有Active队列:
  Queue 1 (PID=100)
  Queue 2 (PID=100)
  Queue 3 (PID=200)
  Queue 4 (PID=200)
  Queue 5 (PID=200)
  
        ↓ pm_create_runlist_ib()
        
构建Runlist IB:
┌──────────────────────────────────┐
│ Runlist Indirect Buffer          │
│                                   │
│ ┌──────────────────────────┐     │
│ │ MAP_PROCESS              │     │
│ │   PASID: 10 (PID=100)    │     │
│ │   Page Table Base: ...   │     │
│ └──────────────────────────┘     │
│                                   │
│ ┌──────────────────────────┐     │
│ │ MAP_QUEUES               │     │
│ │   Queue 1: pipe=0, q=2   │     │
│ │   MQD addr: 0x...        │     │
│ │   Doorbell: ...          │     │
│ └──────────────────────────┘     │
│                                   │
│ ┌──────────────────────────┐     │
│ │ MAP_QUEUES               │     │
│ │   Queue 2: pipe=1, q=0   │     │
│ └──────────────────────────┘     │
│                                   │
│ ┌──────────────────────────┐     │
│ │ MAP_PROCESS              │     │
│ │   PASID: 11 (PID=200)    │     │
│ └──────────────────────────┘     │
│                                   │
│ ┌──────────────────────────┐     │
│ │ MAP_QUEUES               │     │
│ │   Queue 3: pipe=2, q=0   │     │
│ └──────────────────────────┘     │
│                                   │
│ ┌──────────────────────────┐     │
│ │ MAP_QUEUES               │     │
│ │   Queue 4: pipe=3, q=0   │     │
│ └──────────────────────────┘     │
│                                   │
│ ┌──────────────────────────┐     │
│ │ MAP_QUEUES               │     │
│ │   Queue 5: pipe=0, q=3   │     │
│ └──────────────────────────┘     │
└──────────────────────────────────┘
        
        ↓ pm_send_runlist()
        
发送Runlist packet到HIQ:
┌──────────────────────────────────┐
│ HIQ (Hardware Interface Queue)   │
│                                   │
│ ┌──────────────────────────┐     │
│ │ RUNLIST packet           │     │
│ │   IB address: 0x12345678 │     │
│ │   IB size: 2048 dwords   │     │
│ └──────────────────────────┘     │
└──────────────────────────────────┘
        
        ↓ HWS处理
        
HWS读取并执行IB:
  ✓ MAP_PROCESS (PID 100)
  ✓ MAP_QUEUES × 2 (Queue 1, 2)
  ✓ MAP_PROCESS (PID 200)
  ✓ MAP_QUEUES × 3 (Queue 3, 4, 5)
  
结果: 5个队列都加载到HQD ✓
```

---

## 🔄 动态Map/Unmap示例

### 场景：30个队列，但HQD只有24个

```
初始: 创建30个队列，都是active

┌──────────────── 系统内存 ─────────────┐
│ MQD: 30个                              │
│ [1][2][3]...[28][29][30]              │
└───────────────────────────────────────┘
         │
         │ 尝试Map
         ↓
┌──────────────── GPU HQD ──────────────┐
│ 可用HQD: 24个                          │
│ Pipe0: [1][2][3][4][5][6][7][8]       │
│ Pipe1: [9][10][11][12][13][14][15][16]│
│ Pipe2: [17][18][19][20][21][22][23][24]│
│ Pipe3: [░][░][░][░][░][░][░][░]       │
│        ↑ 没有空间了！                  │
└───────────────────────────────────────┘
         ↓
    超过HQD限制
         ↓
┌──────────────── 结果 ─────────────────┐
│ Queue 1-24: Active, 已Map ✓           │
│ Queue 25-30: Inactive, 等待中          │
│                                        │
│ 当Queue 1-24中有队列idle:              │
│   → Unmap idle队列                     │
│   → Map waiting队列 (25-30)            │
│   → 轮流使用HQD ✓                      │
└───────────────────────────────────────┘
```

### 时间线

```
t=0:   创建30个队列
       ├─ 分配30个MQD ✓
       └─ 尝试分配HQD → 只有24个可用

t=1:   Queue 1-24 map到HQD
       ├─ Active: 24个 ✓
       └─ Inactive: 6个(等待)

t=2:   Queue 5执行完成，变idle
       ├─ Unmap Queue 5 (释放HQD)
       └─ Map Queue 25 (使用释放的HQD)

t=3:   Queue 10执行完成
       ├─ Unmap Queue 10
       └─ Map Queue 26

t=4:   ... 继续轮转 ...

结果: 30个队列共享24个HQD ✓
```

---

## 🎭 MI308X多XCC的Map过程

### 1个逻辑队列 → 4个物理HQD

```
创建1个队列:
  │
  ├─ 步骤1: 分配HQD槽位
  │   └─ allocate_hqd() → (pipe=1, queue=3)
  │
  └─ 步骤2: 在4个XCC加载
  
┌──────── XCC 0 ────────┐    ┌──────── XCC 1 ────────┐
│ Pipe 0: [░][░][░][...] │    │ Pipe 0: [░][░][░][...] │
│ Pipe 1: [░][░][░][✓]   │    │ Pipe 1: [░][░][░][✓]   │
│           ↑Queue 3      │    │           ↑Queue 3      │
│           MQD加载 ✓     │    │           MQD加载 ✓     │
│ Pipe 2: [░][░][░][...] │    │ Pipe 2: [░][░][░][...] │
│ Pipe 3: [░][░][░][...] │    │ Pipe 3: [░][░][░][...] │
└───────────────────────┘    └───────────────────────┘

┌──────── XCC 2 ────────┐    ┌──────── XCC 3 ────────┐
│ Pipe 0: [░][░][░][...] │    │ Pipe 0: [░][░][░][...] │
│ Pipe 1: [░][░][░][✓]   │    │ Pipe 1: [░][░][░][✓]   │
│           ↑Queue 3      │    │           ↑Queue 3      │
│           MQD加载 ✓     │    │           MQD加载 ✓     │
│ Pipe 2: [░][░][░][...] │    │ Pipe 2: [░][░][░][...] │
│ Pipe 3: [░][░][░][...] │    │ Pipe 3: [░][░][░][...] │
└───────────────────────┘    └───────────────────────┘

结果: 1个MQD → 4个HQD ⭐
```

### GPU任务执行

```
提交Kernel到这个队列:
  │
  ├─ Wavefront可能在任何XCC执行
  │   ├─ XCC 0空闲 → 在XCC 0执行 ✓
  │   ├─ XCC 1空闲 → 在XCC 1执行 ✓
  │   └─ ...
  │
  └─ 因为所有XCC都加载了MQD
      所以任何XCC都可以直接使用 ✓
      无需动态加载
```

---

## 📊 HQD位图管理可视化

### allocated_queues位图

```
dqm->allocated_queues[pipe] = 8-bit位图

Pipe 0:  0b11111100
            ││││││└└─ Queue 0-1: 已占用(0)
            │││││└─── Queue 2: 空闲(1) ← 可分配
            └└└└└──── Queue 3-7: 空闲(1)

Pipe 1:  0b11111111
            └└└└└└└└─ Queue 0-7: 全空闲

Pipe 2:  0b11110000
            ││││└└└└─ Queue 0-3: 已占用
            └└└└───── Queue 4-7: 空闲

Pipe 3:  0b00000000
            └└└└└└└└─ Queue 0-7: 全占用(无空闲)
```

### 分配操作

```
allocate_hqd() 查找过程:

Step 1: 检查Pipe 0
  allocated_queues[0] = 0b11111100 ≠ 0
  ├─ ffs(0b11111100) = 3 (第3位是第一个1)
  ├─ bit = 3 - 1 = 2
  └─ 分配: (pipe=0, queue=2) ✓

清除bit:
  0b11111100 & ~(1 << 2)
  = 0b11111100 & 0b11111011
  = 0b11111000  ← Queue 2也被标记为占用

next_pipe_to_allocate = (0 + 1) % 4 = 1
```

### 释放操作

```
deallocate_hqd(dqm, q)  // q: pipe=0, queue=2

置位bit:
  allocated_queues[0] |= (1 << 2)
  = 0b11111000 | 0b00000100
  = 0b11111100  ← Queue 2重新标记为空闲 ✓
```

---

## 🔗 通信链路可视化

### KFD ←→ HWS通信

```
┌─────────────┐
│   KFD驱动    │
│  (CPU侧)    │
└──────┬──────┘
       │
       │ 1. 准备Packet
       │    (MAP/UNMAP/QUERY)
       ↓
┌─────────────┐
│ HIQ (特殊队列)│
│  MEC 2, P1, Q0│  ← 专门用于管理
└──────┬──────┘
       │
       │ 2. Ring Doorbell
       │    (通知GPU)
       ↓
┌─────────────┐
│  GPU HWS    │  ← 硬件调度器
│ (GPU固件)   │
└──────┬──────┘
       │
       │ 3. 读取HIQ
       │    解析Packet
       ↓
┌─────────────┐
│  MEC 0 HQD  │  ← 实际工作队列
│  (用户队列)  │
└─────────────┘
       │
       │ 4. 更新Fence
       │    (完成信号)
       ↓
┌─────────────┐
│   KFD驱动    │
│ (检测Fence) │  ← 等待完成
└─────────────┘
```

---

## ⏱️ 时序图

### Map操作时序

```
KFD                 HIQ                HWS                HQD
 │                   │                  │                  │
 │ build_runlist     │                  │                  │
 ├──────────────────>│                  │                  │
 │                   │                  │                  │
 │ submit_packet     │                  │                  │
 ├──────────────────>│                  │                  │
 │                   │                  │                  │
 │ ring_doorbell     │                  │                  │
 ├──────────────────>│ fetch_packet     │                  │
 │                   ├─────────────────>│                  │
 │                   │                  │                  │
 │                   │                  │ parse_runlist    │
 │                   │                  ├─────────────────>│
 │                   │                  │                  │
 │                   │                  │   load_mqd       │
 │                   │                  │  (XCC 0,1,2,3)   │
 │                   │                  │<─────────────────┤
 │                   │                  │                  │
 │                   │                  │ update_fence     │
 │                   │<─────────────────┤                  │
 │ fence_complete    │                  │                  │
 │<──────────────────┤                  │                  │
 │                   │                  │                  │
 ✓ Map完成           ✓                  ✓                  ✓
```

### Unmap操作时序

```
KFD                 HIQ                HWS                HQD
 │                   │                  │                  │
 │ build_unmap_pkt   │                  │                  │
 ├──────────────────>│                  │                  │
 │                   │                  │                  │
 │ submit_packet     │                  │                  │
 ├──────────────────>│                  │                  │
 │                   │                  │                  │
 │ ring_doorbell     │                  │                  │
 ├──────────────────>│ fetch_packet     │                  │
 │                   ├─────────────────>│                  │
 │                   │                  │                  │
 │                   │                  │ grace_period     │
 │                   │                  │ wait 10ms        │
 │                   │                  ├─ ─ ─ ─ ─ ─ ─ ─ ─>│
 │                   │                  │                  │
 │                   │                  │  save_wavefront  │
 │                   │                  │  (if CWSR)       │
 │                   │                  │<─────────────────┤
 │                   │                  │                  │
 │                   │                  │  unload_hqd      │
 │                   │                  │  (XCC 0,1,2,3)   │
 │                   │                  │<─────────────────┤
 │                   │                  │                  │
 │ send_query        │                  │                  │
 ├──────────────────>│                  │                  │
 │                   │                  │                  │
 │ wait_fence        │                  │ update_fence     │
 │<─ ─ ─ ─ ─ ─ ─ ─ ─ ┤<─────────────────┤                  │
 │                   │                  │                  │
 ✓ Unmap完成         ✓                  ✓                  ✓
```

---

## 🎯 关键发现总结

### 1. Map/Unmap不是1:1操作

```
不是:
  1个MQD → 1个HQD

而是:
  1个MQD → 4个HQD (MI308X, 4个XCC)
  
原因:
  - 多XCC架构
  - 任务可能在任何XCC执行
  - 所有XCC都需要加载MQD
```

### 2. Map/Unmap是批量操作

```
不是逐个队列操作:
  ❌ map(q1), map(q2), map(q3), ...
  ❌ 开销大，延迟高

而是批量Runlist:
  ✓ 构建包含所有队列的Runlist IB
  ✓ 一次发送给HWS
  ✓ HWS批量处理
  ✓ 开销小，延迟低
```

### 3. HQD分配使用Round-robin

```
目的: 负载均衡

策略:
  - 轮询Pipe 0 → 1 → 2 → 3 → 0 ...
  - 每个Pipe找第一个空闲Queue
  - next_pipe_to_allocate记录起始点
  
结果:
  ✓ 队列均匀分布到所有Pipe
  ✓ 避免单个Pipe过载
  ✓ 最大化并行度
```

### 4. 支持超额订阅(Oversubscription)

```
可以创建的队列数 > HQD数量

条件:
  ✅ 不是所有队列都同时active
  ✅ Active数量 ≤ HQD数量
  ✅ 动态Map/Unmap管理
  
示例:
  - 创建100个队列（MQD）
  - 但只有30个HQD
  - 同时active的 ≤ 30
  - 其他队列等待或inactive
  - 系统自动调度 ✓
```

---

## 📚 文档导航

我创建了3个详细文档：

### 1. `SW_QUEUE_HW_QUEUE_MAPPING_MECHANISM.md`
- 📖 完整的Map/Unmap机制
- 🔬 队列生命周期详解
- 📊 性能分析和优化
- **适合**: 全面了解整个机制

### 2. `MAP_UNMAP_DETAILED_PROCESS.md`
- 🎯 函数调用链完整分析
- 📦 Packet Manager机制
- ⏱️ Grace Period和Preemption
- **适合**: 深入代码实现细节

### 3. `MAP_UNMAP_SUMMARY_CN.md` (中文总结)
- 🎯 核心概念中文解释
- 📊 DSV3.2测试数据解释
- 🔄 完整流程示例
- **适合**: 快速理解要点

### 4. `MAP_UNMAP_VISUAL_GUIDE.md` (本文档)
- 🎨 可视化图表
- 📈 时序图
- 💡 动态过程演示
- **适合**: 直观理解流程

---

## 🎓 快速要点

### 5秒版本
```
Map = MQD加载到HQD
Unmap = MQD从HQD卸载
目的 = 动态管理有限的硬件队列资源
```

### 30秒版本
```
软件队列(MQD):
  - 系统内存，数量不限
  - 可以很多个

硬件队列(HQD):
  - GPU硬件，数量有限（30/XCC）
  - 只给active队列使用

Map/Unmap:
  - 动态分配HQD给MQD
  - 批量操作（Runlist机制）
  - HWS自动管理
  - MI308X: 1个MQD → 4个HQD（4个XCC）
```

### 2分钟版本
```
创建队列:
  1. 分配MQD（系统内存）- 轻量
  2. 如果is_active: allocate_hqd()分配硬件槽位
  3. execute_queues_cpsch(): Unmap旧队列 + Map新队列
  4. pm_send_runlist(): 发送Runlist IB到HIQ
  5. HWS处理: 读取IB，加载所有队列到HQD
  6. MI308X: 每个队列在4个XCC都加载

执行任务:
  - 队列active，HQD持续处理任务
  - Wavefront可能在任何XCC执行
  - 所有XCC的HQD都可用

队列idle/销毁:
  1. unmap_queues_cpsch(): 发送Unmap packet
  2. HWS: 等待grace period，保存/drain wavefront
  3. HWS: 从4个XCC的HQD卸载
  4. deallocate_hqd(): 释放槽位
  5. free_mqd(): 释放MQD内存

关键:
  - 批量操作（不是逐个）
  - HWS自动化（不是CPU手动）
  - 多XCC并行（1个MQD→4个HQD）
  - 动态分配（支持超额订阅）
```

---

**创建时间**: 2026-02-03  
**图表数量**: 10+  
**理解难度**: ⭐⭐ (已简化)  
**完整性**: ⭐⭐⭐⭐⭐
