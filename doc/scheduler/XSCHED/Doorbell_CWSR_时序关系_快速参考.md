# Doorbell + CWSR 时序关系 - 快速参考

**日期**: 2026-01-27  
**目的**: 解释高优先级任务通过 doorbell 提交后，如何与 CWSR 抢占配合

---

## 🎯 一句话总结

**两个队列都通过 doorbell 快速提交，GPREEMPT 在内核态异步监控，发现优先级倒置时使用 CWSR 强制纠正。**

---

## 📊 核心架构图

```
┌─────────────────────────────────────────────────────────────┐
│  应用层（两个独立应用）                                      │
│                                                             │
│  训练任务 (Low)              推理服务 (High)                │
│      ↓                            ↓                         │
│  hipLaunchKernel()           hipLaunchKernel()             │
│      ↓                            ↓                         │
│  *doorbell_train = wptr      *doorbell_infer = wptr        │
│      ↓ (~100ns)                   ↓ (~100ns)               │
│                                                             │
│  ✅ 两个队列都保留 doorbell 快速提交！                       │
└─────────────────────────────────────────────────────────────┘
              ↓                          ↓
┌─────────────────────────────────────────────────────────────┐
│  GPU 硬件层                                                  │
│                                                             │
│  Queue_train (priority=1)    Queue_infer (priority=10)     │
│  Ring Buffer                 Ring Buffer                   │
│      ↓                            ↓                         │
│      └──────────┬─────────────────┘                         │
│                 ↓                                           │
│     GPU Command Processor (硬件调度器)                      │
│                 ↓                                           │
│     可能选择 Queue_train ❌ (优先级支持有限)                │
│                 ↓                                           │
│     执行低优先级任务 (错误！)                                │
└─────────────────────────────────────────────────────────────┘
              ↑ CWSR 抢占
              │ (由 GPREEMPT 触发)
┌─────────────────────────────────────────────────────────────┐
│  内核态：GPREEMPT 监控线程                                   │
│                                                             │
│  while (true) {                                            │
│    // 1. 读取硬件状态 (MMIO)                               │
│    Queue_train: rptr, wptr                                 │
│    Queue_infer: rptr, wptr                                 │
│                                                             │
│    // 2. 检测优先级倒置                                    │
│    if (Queue_infer 有任务等待 &&                            │
│        Queue_train 正在运行 &&                              │
│        Queue_infer.priority > Queue_train.priority) {      │
│      // 3. 触发 CWSR 抢占                                  │
│      cwsr_preempt(Queue_train);  // 1-10μs                │
│    }                                                        │
│                                                             │
│    sleep(5ms);  // 定期检查                                │
│  }                                                          │
└─────────────────────────────────────────────────────────────┘
```

---

## ⏱️ 完整时间线（推理抢占训练）

```
时刻            事件                                     延迟
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

T < 0ms        训练任务运行中
               • Queue_train 通过 doorbell 提交
               • GPU 正在执行
               
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

T = 0ms        推理任务到达
               hipLaunchKernel()
                 ↓
               *doorbell_infer = wptr                 ~100ns ✅
                 ↓
               任务提交成功，函数返回
               
               GPU 状态:
               • Queue_train: 正在执行 ❌
               • Queue_infer: 在队列中等待 ⏳
               
               问题: GPU 硬件没有抢占低优先级任务！

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

T = 0-5ms      高优先级任务等待
               • Queue_infer 在队列中
               • 等待 GPREEMPT 检测

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

T = 5ms        GPREEMPT 监控线程检测
               
               读取硬件寄存器:
               • Queue_train: rptr=100, wptr=500
                 → pending=400 (运行中)
               • Queue_infer: rptr=0, wptr=1
                 → pending=1 (等待中)
               
               检测: 优先级倒置！
               • Queue_infer (prio=10) 等待
               • Queue_train (prio=1) 运行
               
               决策: 抢占 Queue_train
                 ↓
               kfd_queue_preempt(Queue_train, CWSR)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

T = 5.001ms    CWSR 硬件抢占执行
               
               Trap Handler:
               • 暂停所有 Wavefronts
               • 保存状态到 CWSR 内存:
                 - PC, SGPRs, VGPRs, LDS...
               • Queue_train 被挂起                  1-10μs ✅
               
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

T = 5.001ms    GPU 切换到高优先级队列
               
               Command Processor:
               • Queue_train 已挂起，跳过
               • 发现 Queue_infer 有任务
               • 开始执行 Queue_infer ✅            <1ms

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

T = 5-25ms     高优先级任务执行
               • Queue_infer 占用 GPU               ~20ms
               • Queue_train 保持挂起状态

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

T = 25ms       高优先级任务完成
               • Queue_infer: rptr=1, wptr=1
               • 队列空闲

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

T = 30ms       GPREEMPT 监控线程恢复
               
               检测: Queue_infer 空闲
               决策: 恢复 Queue_train
                 ↓
               kfd_queue_resume(Queue_train)
                 ↓
               CWSR 恢复 Wave 状态                  1-10μs ✅
               Queue_train 从断点继续执行

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

T = 30ms+      低优先级任务继续
               • Queue_train 从中断处继续
               • 应用完全无感知
               • 总延迟增加: ~25ms

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

总结:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

高优先级延迟:   ~25ms (5ms等待 + 20ms执行)
低优先级延迟:   +25ms (被抢占时间)
Doorbell 性能:  ~100ns ✅ (完全保留)
CWSR 抢占延迟:  1-10μs ✅
调度检测延迟:   5ms (可配置 1-10ms)
```

---

## 🔑 关键要点

### 1. 两个队列都使用 Doorbell

```
误解: "高优先级任务不走 doorbell，直接抢占"
❌ 错误！

正确:
✅ 高优先级任务也通过 doorbell 提交 (~100ns)
✅ 低优先级任务也通过 doorbell 提交 (~100ns)
✅ 两者都保留快速提交性能

区别在于:
• GPU 硬件可能选错队列（优先级支持有限）
• GPREEMPT 在内核态"事后"检测和纠正
```

### 2. GPU 硬件调度的局限

```
问题: AMD GPU 的 Command Processor 为什么会选错？
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

原因:
1. 硬件调度器优先级支持有限
   • 可能只有 3 级（high/normal/low）
   • 或者根本不支持优先级

2. Round-robin 或其他策略
   • 为了公平性，轮流调度
   • 不考虑用户态定义的优先级

3. 已经在执行的任务不会被硬件抢占
   • GPU 不像 CPU 有时钟中断
   • 需要软件干预（CWSR）

这就是为什么需要 GPREEMPT！
```

### 3. GPREEMPT 的作用

```
GPREEMPT = 软件优先级调度器
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

功能:
✓ 监控所有队列状态（读取硬件寄存器）
✓ 检测优先级倒置
✓ 使用 CWSR 强制抢占
✓ 自动恢复被抢占的队列

特点:
✓ 完全在内核态
✓ 应用透明（无需修改）
✓ 保留 doorbell 性能
✓ 可靠的优先级保证
```

### 4. 为什么不拦截 Doorbell？

```
方案对比:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

拦截方案（类似 XSched Lv1/Lv2）:
  应用 → LD_PRELOAD → 调度决策 → doorbell
         ~~~~~~~~~~   ~~~~~~~~~
         10-100μs     额外延迟
  
  问题:
  ❌ 每次提交都有开销（10-100μs vs 原生100ns）
  ❌ 需要 LD_PRELOAD（应用配合）
  ❌ 损失 doorbell 的快速路径
  ❌ 性能下降 100-1000 倍！

GPREEMPT 方案（事后监控）:
  应用 → doorbell (~100ns) → GPU
                             ↓
                      GPREEMPT 监控 (1-10ms 后)
                             ↓
                      CWSR 纠正 (1-10μs)
  
  优点:
  ✅ 提交延迟 = 原生 (~100ns)
  ✅ 无需应用配合
  ✅ 保留 doorbell 性能
  ✅ 完全透明
  
  权衡:
  ⚠️ 调度延迟 = 监控间隔（1-10ms）
     但仍远优于无优先级（可能数秒）
```

---

## 🎯 与 XSched 的关系

```
XSched Lv3 接口需求:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

XSched 定义:
  int interrupt(hwQueue hwq);   // 中断正在运行的队列
  int restore(hwQueue hwq);     // 恢复被中断的队列

GPREEMPT 实现:
  int interrupt(hwQueue hwq) {
    return ioctl(kfd_fd, AMDKFD_IOC_PREEMPT_QUEUE, &args);
  }
  
  int restore(hwQueue hwq) {
    return ioctl(kfd_fd, AMDKFD_IOC_RESUME_QUEUE, &args);
  }

完美匹配！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

GPREEMPT (Paper#1)           =  XSched Lv3 (Paper#2)
↓                                ↓
内核态监控 + CWSR 抢占          硬件级抢占接口
↓                                ↓
ioctl(PREEMPT_QUEUE)           interrupt()
ioctl(RESUME_QUEUE)            restore()

两篇论文完美融合！
```

---

## 📈 性能数据

| 指标 | 值 | 说明 |
|------|-----|------|
| **Doorbell 提交延迟** | ~100ns | ✅ 完全保留原生性能 |
| **CWSR 抢占延迟** | 1-10μs | ✅ 硬件级快速抢占 |
| **CWSR 恢复延迟** | 1-10μs | ✅ 从断点继续 |
| **调度检测延迟** | 1-10ms | ⚠️ 可配置，权衡延迟和开销 |
| **高优先级端到端延迟** | ~5-25ms | 检测延迟 + 执行时间 |
| **应用透明性** | 100% | ✅ 无需修改应用 |
| **性能开销** | <2% | ✅ 监控线程开销很小 |

---

## 💡 常见问题

### Q1: 为什么不让 GPU 硬件直接支持优先级？

**A**: AMD GPU 的硬件调度器优先级支持有限，或者支持的粒度不够（如只有 3 级）。GPREEMPT 提供软件实现，可以支持任意优先级级别（如 0-15），更灵活。

### Q2: 监控间隔 5ms 会不会太慢？

**A**: 对比：
- 无优先级：低优先级任务可能运行数秒到数分钟
- GPREEMPT：最多等待 5ms（检测间隔）
- 5ms 对大多数场景足够（推理延迟通常 10-100ms）
- 可配置更快（1ms），但开销会增加

### Q3: CWSR 保存状态会不会很慢？

**A**: 不会！CWSR 是硬件支持的：
- 1-10μs 完成抢占（保存状态）
- 1-10μs 完成恢复
- 相比 GPU kernel 执行时间（毫秒级），几乎可以忽略

### Q4: 能不能做到实时抢占（<1ms）？

**A**: 可以优化：
- 减少监控间隔到 1ms（但开销会增加）
- 或者添加"紧急抢占"通知机制（用户态 → 内核态）
- 但即使 5ms，也比无优先级好 1000 倍

---

## 📚 相关文档

- **详细设计**: `GPREEMPT_作为_XSched_Lv3_实现方案.md`
- **技术分析**: `CWSR到优先级调度_关键缺失环节分析.md`
- **硬件级别**: `XSched_Lv1_Lv2_Lv3硬件级别详解.md`

---

**文档版本**: v1.0  
**创建日期**: 2026-01-27  
**目的**: 快速理解 Doorbell + CWSR 的配合机制

