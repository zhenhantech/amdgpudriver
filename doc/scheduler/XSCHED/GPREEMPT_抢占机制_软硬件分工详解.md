# GPreempt 抢占机制：软件与硬件的分工详解

**日期**: 2026-01-28  
**核心问题**: 在 GPreempt (NVIDIA) 中，kernel 抢占时软件（内核驱动）需要参与吗？  
**答案**: **需要，但角色有限**

---

## 🎯 核心结论（TL;DR）

```
GPreempt 抢占过程中的软硬件分工:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

软件（驱动）的角色:
✅ 触发抢占（接收 ioctl 命令）
✅ Context 管理（查找、标记）
✅ Channel 调度管理
⚠️ 可能参与状态保存的初始化
❌ 不参与实际的状态保存（硬件完成）

硬件的角色:
✅ 检测抢占信号
✅ 等待合适的抢占点（Thread Block 边界）
✅ 保存所有 Thread/Warp 状态
✅ 释放 SM 资源
✅ 切换到新 Context

结论: "软件触发 + 硬件执行" 模式
```

---

## 📊 详细分析：抢占全流程

### 完整时间线

```
T=0: 用户态触发抢占请求
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
┌──────────────────────────────────────┐
│ GPreempt 用户态代码                   │
│   NvRmPreempt(ctx)                   │
│     ↓                                │
│   NvRmControl(                       │
│     hClient,                         │
│     hObject,                         │
│     NVA06C_CTRL_CMD_PREEMPT,  ⭐     │
│     &params                          │
│   )                                  │
└──────────────────────────────────────┘
           ↓ ioctl (系统调用 ~1-10μs)


T=1μs: 内核驱动处理 ioctl
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
┌──────────────────────────────────────────────────────────┐
│ NVIDIA Kernel Driver (nvidia.ko)                         │
│                                                           │
│ 1. 接收 ioctl 命令                                       │
│    • 命令: NVA06C_CTRL_CMD_PREEMPT (0xa06c0105)         │
│    • 参数: hClient, hObject, bWait, timeoutUs           │
│                                                           │
│ 2. 查找目标 Context/TSG (Thread State Group)            │
│    • 根据 hClient/hObject 查找                          │
│    • 验证权限                                            │
│                                                           │
│ 3. 标记 Context 为 "待抢占"                              │
│    • 设置 preemption_pending 标志                       │
│    • 记录抢占原因                                        │
│                                                           │
│ 4. 向 GPU 发送抢占命令                                   │
│    • 写硬件寄存器或 MMIO                                 │
│    • 设置 TSG_PREEMPT_TRIGGER 寄存器                    │
│                                                           │
│ 5. 根据 bWait 决定是否等待                              │
│    • bWait=FALSE: 立即返回（异步）⭐                    │
│    • bWait=TRUE: 轮询等待抢占完成                       │
│                                                           │
│ 延迟: 1-5μs（驱动处理开销）                             │
└──────────────────────────────────────────────────────────┘
           ↓ MMIO write 到 GPU


T=2μs: GPU 硬件开始执行抢占
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
┌──────────────────────────────────────────────────────────┐
│ GPU Hardware (NVIDIA Volta/Ampere/Hopper)                │
│                                                           │
│ 1. 检测抢占信号                                          │
│    • Host Interface 读取 TSG_PREEMPT_TRIGGER 寄存器     │
│    • 识别目标 TSG/Channel                               │
│                                                           │
│ 2. 停止新任务调度                                        │
│    • GPC (Graphics Processing Cluster) 停止发射        │
│    • 不再从该 TSG 的 Channel 读取新命令                 │
│                                                           │
│ 3. 等待合适的抢占点                                      │
│    ┌──────────────────────────────────────┐            │
│    │ Thread Block-level Preemption:       │            │
│    │   • 等待当前 Thread Block 完成       │  ← Volta+ │
│    │   • 延迟: ~10μs                      │            │
│    └──────────────────────────────────────┘            │
│                                                           │
│    ┌──────────────────────────────────────┐            │
│    │ Instruction-level Preemption:        │            │
│    │   • 在任意指令边界停止               │  ← Pascal+│
│    │   • 延迟: ~100μs                     │            │
│    └──────────────────────────────────────┘            │
│                                                           │
│ 4. 硬件保存状态（完全由硬件完成）⭐⭐⭐                   │
│    ┌──────────────────────────────────────┐            │
│    │ 每个 SM (Streaming Multiprocessor):  │            │
│    │                                       │            │
│    │ For each active Warp:                │            │
│    │   • PC (Program Counter)             │            │
│    │   • Registers (R0-R255 per thread)   │            │
│    │   • Predicate registers              │            │
│    │   • Shared memory (per Thread Block) │            │
│    │   • Barrier state                    │            │
│    │                                       │            │
│    │ 保存位置:                             │            │
│    │   • Context Save Area (GPU memory)   │            │
│    │   • 由硬件自动管理                   │            │
│    └──────────────────────────────────────┘            │
│                                                           │
│ 5. 释放 SM 资源                                          │
│    • 清空 Warp Scheduler                                │
│    • 释放寄存器文件                                      │
│    • 标记 SM 为空闲                                     │
│                                                           │
│ 6. 更新硬件状态                                          │
│    • 设置 TSG_STATUS = PREEMPTED                        │
│    • 可能触发中断通知驱动（可选）                        │
│                                                           │
│ 总延迟: 10-100μs（取决于抢占粒度）                       │
└──────────────────────────────────────────────────────────┘
           ↓


T=100μs: 抢占完成，硬件切换 Context
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
┌──────────────────────────────────────────────────────────┐
│ GPU Hardware - Context Switch                            │
│                                                           │
│ 1. 扫描 Runlist，选择下一个 TSG                          │
│    • 根据优先级选择                                      │
│    • 可能选择高优先级的 Context                          │
│                                                           │
│ 2. 加载新 Context                                        │
│    • 读取 Context Descriptor                            │
│    • 配置 SM 资源分配                                    │
│                                                           │
│ 3. 恢复状态（如果是恢复被抢占的 Context）                │
│    • 从 Context Save Area 读取状态                      │
│    • 恢复 Warp PC, Registers, Shared Memory             │
│                                                           │
│ 4. 开始执行新 Context 的任务                             │
│                                                           │
│ 延迟: <1ms                                               │
└──────────────────────────────────────────────────────────┘


T=1ms+: （可选）驱动后续处理
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
┌──────────────────────────────────────────────────────────┐
│ NVIDIA Kernel Driver (如果需要)                          │
│                                                           │
│ 1. 如果使用 bWait=TRUE                                   │
│    • 轮询 GPU 状态寄存器                                 │
│    • 确认抢占完成                                        │
│    • 返回给用户态                                        │
│                                                           │
│ 2. 如果收到 GPU 中断                                     │
│    • 中断处理程序                                        │
│    • 更新软件状态                                        │
│                                                           │
│ 3. 管理被抢占 Context 的后续调度                         │
│    • 标记为可恢复                                        │
│    • 等待调度机会                                        │
└──────────────────────────────────────────────────────────┘
```

---

## 🔍 软件与硬件的详细分工

### 1. 软件（NVIDIA 驱动）的职责

```
驱动参与的环节:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

阶段1: 抢占触发
┌────────────────────────────────────────┐
│ ✅ 接收 ioctl 命令                      │
│ ✅ 参数验证（权限、有效性）            │
│ ✅ 查找目标 Context/TSG                │
│ ✅ 标记 Context 状态                   │
│ ✅ 向 GPU 发送抢占信号（写寄存器）     │
│ ⚠️ 可能需要暂停 Channel 调度          │
└────────────────────────────────────────┘

阶段2: 状态保存初始化（可能）
┌────────────────────────────────────────┐
│ ⚠️ 配置 Context Save Area 地址         │
│    （这通常在 Context 创建时完成）     │
│ ⚠️ 确保有足够的 GPU 内存              │
│ ❌ 不参与实际的寄存器保存（硬件做）    │
└────────────────────────────────────────┘

阶段3: 抢占完成后（可选）
┌────────────────────────────────────────┐
│ ⚠️ 如果 bWait=TRUE，轮询等待完成      │
│ ⚠️ 处理 GPU 中断（如果有）            │
│ ✅ 更新软件 Context 状态               │
│ ✅ 管理 Runlist 调度                   │
└────────────────────────────────────────┘

驱动开销: 1-10μs（触发阶段）
```

### 2. 硬件的职责

```
GPU 硬件完成的工作:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

核心抢占执行（完全硬件）:
┌────────────────────────────────────────┐
│ ✅ 检测抢占信号（寄存器监控）          │
│ ✅ 停止任务调度                        │
│ ✅ 选择抢占点（Thread Block/Instr边界）│
│ ✅ 保存完整状态：                      │
│    • 所有 Warp 的 PC                   │
│    • 所有 Thread 的寄存器              │
│    • Shared Memory                     │
│    • Barrier/Semaphore 状态           │
│    • Texture/Surface 绑定             │
│ ✅ 释放 SM 资源                        │
│ ✅ 更新硬件状态标志                    │
│ ✅ Context 切换                        │
│ ✅ 恢复状态（如果需要）                │
└────────────────────────────────────────┘

硬件延迟: 10-100μs（取决于抢占粒度）
```

---

## 📊 与 AMD CWSR 的对比

### 软硬件分工对比

| 阶段 | NVIDIA GPreempt | AMD CWSR | 相似度 |
|------|-----------------|----------|--------|
| **触发抢占** | | | |
| 触发位置 | 用户态 ioctl | 内核态直接调用 | ⚠️ 不同 |
| 驱动角色 | 接收命令 + 查找 Context | 直接触发 | 相似 |
| 触发延迟 | 1-10μs (系统调用) | <1μs (内核态) | AMD 快 |
| **状态保存** | | | |
| 执行者 | GPU 硬件 | GPU Trap Handler (硬件) | ✅ 相同 |
| 驱动参与 | 仅初始化配置 | 仅触发命令 | ✅ 相同 |
| 保存内容 | PC+Regs+Shared+Barrier | PC+SGPRs+VGPRs+LDS+ACC | ✅ 相似 |
| 保存延迟 | 10-100μs | 1-10μs | AMD 快10倍 |
| **Context 切换** | | | |
| 执行者 | GPU 硬件 | GPU 硬件 | ✅ 相同 |
| 驱动参与 | Runlist 管理 | MQD 管理 | ✅ 相似 |
| **恢复** | | | |
| 执行者 | GPU 硬件 | GPU Trap Handler | ✅ 相同 |
| 驱动参与 | 触发恢复命令 | 触发恢复命令 | ✅ 相同 |

### 核心差异

```
关键差异总结:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. 触发路径:
   NVIDIA: 用户态 → ioctl → 驱动 → GPU
           ~~~~~~   ~~~~~   ~~~~
           额外开销 1-10μs

   AMD:    内核态监控线程 → 驱动函数 → GPU
           ~~~~~~~~~~~~~~~~   ~~~~~~~~~
           直接调用，无系统调用开销

2. 硬件执行:
   NVIDIA: Thread Block-level (10-100μs)
   AMD:    Wave-level (1-10μs) ✅ 快10倍

3. 驱动复杂度:
   NVIDIA: 需要打补丁（闭源）
   AMD:    直接修改（开源）

4. 共同点:
   ✅ 都是"软件触发 + 硬件执行"模式
   ✅ 实际状态保存都由硬件完成
   ✅ 驱动主要负责管理和触发，不参与实际保存
```

---

## 🎮 代码证据

### 1. GPreempt 的异步抢占

```cpp
// src/gpreempt.cpp

NV_STATUS NvRmPreempt(NvContext ctx) {
    NVA06C_CTRL_PREEMPT_PARAMS preemptParams;
    
    // ⭐ 关键：bWait = FALSE（异步）
    preemptParams.bWait = NV_FALSE;
    
    // 说明：驱动发送命令后立即返回
    // 不等待 GPU 完成抢占
    // GPU 自己完成状态保存
    
    preemptParams.bManualTimeout = NV_FALSE;
    
    return NvRmControl(
        ctx.hClient, 
        ctx.hObject, 
        NVA06C_CTRL_CMD_PREEMPT,
        (NvP64)&preemptParams, 
        sizeof(preemptParams)
    );
}
```

**分析**：
- `bWait = FALSE` 说明是异步操作
- 驱动只负责发送命令，不等待完成
- GPU 硬件自己完成抢占和状态保存
- 如果驱动需要参与状态保存，这里会设置 `bWait = TRUE` 并等待

### 2. 驱动补丁的作用

```cpp
// patch/driver.patch

// 添加查询 Channel Group 的功能
#define NV_ESC_RM_QUERY_GROUP  0x60

// 目的：
// - 让用户态可以查询 Context/Channel 信息
// - 查找哪些 Channel 属于哪个 TSG
// - 方便批量管理和抢占

// 注意：
// - 补丁不涉及状态保存逻辑
// - 只是暴露了管理接口
// - 说明状态保存由硬件完成，不需要修改
```

---

## 🔑 核心结论

### 回答您的问题

**Q: GPreempt (NVIDIA) 中，kernel 抢占时软件（内核驱动）需要参与吗？**

**A: 需要，但参与有限：**

```
软件（驱动）的参与:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✅ 需要参与的部分（软件控制）:
   1. 接收和验证 ioctl 抢占命令
   2. 查找目标 Context/TSG
   3. 标记 Context 状态
   4. 向 GPU 发送抢占信号（写寄存器）
   5. 管理 Context 的后续调度
   
   延迟: 1-10μs

❌ 不需要参与的部分（硬件自动）:
   1. 实际的状态保存（寄存器、Shared Memory）
   2. 等待抢占点（Thread Block 边界）
   3. 释放 SM 资源
   4. Context 切换
   5. 状态恢复
   
   延迟: 10-100μs

总结:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

驱动的角色: "触发器 + 管理员"
• 触发抢占（写硬件寄存器）
• 管理 Context 生命周期
• 不参与繁重的状态保存工作

硬件的角色: "执行者"
• 完成所有实际的状态保存
• 选择抢占时机
• 执行 Context 切换

这种设计的好处:
✓ 减轻驱动负担
✓ 降低抢占延迟（硬件快）
✓ 保证正确性（硬件原子操作）
```

### 与 AMD CWSR 的本质相同

```
两者都是"软件触发 + 硬件执行"模式:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

NVIDIA GPreempt:
  驱动触发 → GPU 硬件执行 Thread Block Preemption
  (软件)      (硬件)

AMD CWSR:
  驱动触发 → GPU Trap Handler 执行 Wave Save/Restore
  (软件)      (硬件)

核心相同:
✓ 都是软件负责触发和管理
✓ 都是硬件负责实际的状态保存
✓ 都利用了硬件的 Context Switch 能力

差异:
⚠️ NVIDIA: 触发需要用户态 ioctl（慢）
✅ AMD: 触发在内核态直接调用（快）
⚠️ NVIDIA: 硬件抢占 10-100μs
✅ AMD: 硬件抢占 1-10μs（快10倍）
```

---

**文档版本**: v1.0  
**创建日期**: 2026-01-28  
**核心问题**: kernel 抢占时软件是否参与？  
**核心答案**: 软件触发 + 硬件执行（与 AMD 类似）

**相关文档**:
- `GPREEMPT_实际代码分析_命令提交机制.md`
- `GPREEMPT_NVIDIA平台分析_命令提交与抢占机制.md`

